var Metric = function (name) {
  this.name = name;
  this.sum = 0;
  this.content = {};
  this.autoGeneratedKey = - 1;

  this.minHalfHeap = new BinaryHeapIndex(function (child, parent) {
    return child >= parent;
  });
  this.maxHalfHeap = new BinaryHeapIndex(function (child, parent) {
    return child <= parent;
  });
  this.minHeap = new BinaryHeapIndex(function (child, parent) {
    return child >= parent;
  });
  this.maxHeap = new BinaryHeapIndex(function (child, parent) {
    return child <= parent;
  });
};

Metric.prototype = {
  insert: function (element) {
    this.autoGeneratedKey ++;
    this.content[this.autoGeneratedKey] = element;
    this.maxHeap.push(this.autoGeneratedKey, this.content);
    this.minHeap.push(this.autoGeneratedKey, this.content);
    this.sum += element.value;
    if (this.size() % 2 === 0) {
      this.maxHalfHeap.push(this.autoGeneratedKey, this.content);
      if (!this.minHalfHeap.content.length) {
        return;
      }
      if (this.maxHalfHeap.content[0] > this.minHalfHeap.content[0]) {
        var toMax = this.minHalfHeap.pop(this.content);
        var toMin = this.maxHalfHeap.pop(this.content);
        this.minHalfHeap.push(toMin, this.content);
        this.maxHalfHeap.push(toMax, this.content);
      }
    } else {
      this.maxHalfHeap.push(this.autoGeneratedKey, this.content);
      var toMin = this.maxHalfHeap.pop(this.content);
      this.minHalfHeap.push(toMin, this.content);
    }
  },
  median: function () {
    if (this.size() % 2 === 0) {
      return (this.content[this.minHalfHeap.content[0]].value +
        this.content[this.maxHalfHeap.content[0]].value) / 2.0;
    } else {
      return this.content[this.maxHalfHeap.content[0]].value;
    }
  },
  size: function () {
    return this.autoGeneratedKey + 1;
  },
  average: function() {
    return this.sum / (this.autoGeneratedKey + 1); 
  },
  min: function() {
    return this.content[this.minHeap.content[0]].value
  },
  max: function() {
    return this.content[this.maxHeap.content[0]].value;
  },

};

function BinaryHeapIndex (comparingFunction) {
  this.content = [];
  this.comparingFunction = comparingFunction || function (i, j) { return i >= j };
}
BinaryHeapIndex.prototype = {
  _swap: function (child, parent, referenceContent) {
    var childValue, parentValue;
    if (referenceContent === undefined) {
      childValue = this.content[child];
      parentValue = this.content[parent]
    } else {
      childValue = referenceContent[this.content[child]].value;
      parentValue = referenceContent[this.content[parent]].value;
    }
    if (!this.comparingFunction(childValue, parentValue)) {
      var archive = this.content[child];
      this.content[child] = this.content[parent];
      this.content[parent] = archive;
      return true;
    } else {
      return false;
    }
  },
  _parentIndex: function (index) {
    return Math.floor((index - 1) / 2)
  },
  _childrenIndices: function (index) {
    return [index * 2 + 1, index * 2 + 2]
  },
  size: function () {
    return this.content.length;
  },  
  pop: function(referenceContent) {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0, referenceContent);
    }
    return result;  
  },
  push: function(value, referenceContent) {
    this.content.push(value);
    this.bubbleUp(this.content.length - 1, referenceContent);
  },
  bubbleUp: function(index, referenceContent) {
    if (index !== 0 && this._swap(index, this._parentIndex(index), referenceContent)) {
      this.bubbleUp(this._parentIndex(index), referenceContent);
    } else {
      return;
    }
  },
  sinkDown: function(index, referenceContent) {
    if (index === this.content.length - 1) {
      return;
    }
    this._childrenIndices(index).forEach(function(child) {
      if (child >= this.content.length - 1) {
        return
      }
      if (this._swap(child, index, referenceContent)) {
        this.sinkDown(child, referenceContent);
      } else {
        return;
      }
    }.bind(this))
  }
}
module.exports.Metric = Metric;
module.exports.BinaryHeapIndex = BinaryHeapIndex;
